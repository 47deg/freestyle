<html><head><title>Freestyle</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="47 Degrees" /><meta name="description" content="A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries" /><meta name="og:image" content="/img/poster.png" /><meta name="og:title" content="Freestyle" /><meta name="og:site_name" content="Freestyle" /><meta name="og:url" content="https://frees-io.github.io/freestyle/" /><meta name="og:type" content="website" /><meta name="og:description" content="A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries" /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="Freestyle" /><meta name="twitter:image" content="https://frees-io.github.io/freestyle/img/poster.png" /><meta name="twitter:description" content="A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/dracula.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /><link rel="stylesheet" href="/css/custom.css" /><link rel="stylesheet" href="/css/theme-code.css" /><script async="async">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-18433785-14' , 'auto');
ga('send', 'pageview');
      </script></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>Freestyle</span></div></a></li> <li><a href="/docs/" class="">Quick Start</a></li> <li><a href="/docs/core/" class="">Core Concepts</a> <ul class="sub_section"> <li><a href="/docs/core/algebras/" class="">Algebras</a></li> <li><a href="/docs/core/modules/" class="">Modules</a></li> <li><a href="/docs/core/handlers/" class=" active ">Handlers</a></li> <li><a href="/docs/core/parallelism/" class="">Parallelism</a></li> <li><a href="/docs/core/tagless/" class="">Tagless Final</a></li></ul></li> <li><a href="/docs/effects/" class="">Effects</a> <ul class="sub_section"> <li><a href="/docs/effects/error" class="">Error</a></li> <li><a href="/docs/effects/either" class="">Either</a></li> <li><a href="/docs/effects/option" class="">Option</a></li> <li><a href="/docs/effects/reader" class="">Reader</a></li> <li><a href="/docs/effects/writer" class="">Writer</a></li> <li><a href="/docs/effects/state" class="">State</a></li> <li><a href="/docs/effects/traverse" class="">Traverse</a></li> <li><a href="/docs/effects/validation" class="">Validation</a></li> <li><a href="/docs/effects/async" class="">Async Callbacks</a></li></ul></li> <li><a href="/docs/optimizations/" class="">Optimizations</a></li> <li><a href="/docs/stack/" class="">Example Target Stack</a></li> <li><a href="/TODO.html" class="">Patterns</a> <ul class="sub_section"> <li><a href="/docs/effects/Cache/" class="">Cache</a></li> <li><a href="/TODO.html" class="">Dependency Injection</a></li> <li><a href="/docs/patterns/config" class="">Configuration</a></li> <li><a href="/docs/patterns/logging" class="">Logging</a></li></ul></li> <li><a href="/docs/integrations" class="">Integrations</a> <ul class="sub_section"> <li><a href="/docs/integrations/cats" class="">Cats</a></li> <li><a href="/docs/integrations/play" class="">Play Framework</a></li> <li><a href="/docs/integrations/monix" class="">Monix</a></li> <li><a href="/docs/integrations/fetch" class="">Fetch</a></li> <li><a href="/docs/integrations/doobie" class="">Doobie</a></li> <li><a href="/docs/integrations/slick" class="">Slick</a></li> <li><a href="/docs/integrations/akkahttp" class="">Akka HTTP</a></li> <li><a href="/docs/integrations/finch" class="">Finch</a></li> <li><a href="/docs/integrations/http4s" class="">http4s</a></li> <li><a href="/docs/integrations/hammock" class="">Hammock</a></li></ul></li> <li><a href="/docs/rpc" class="">Libraries</a> <ul class="sub_section"> <li><a href="/docs/rpc" class="">Microservices</a></li> <li><a href="/docs/effects" class="">Effects</a></li> <li><a href="/docs/cassandra" class="">Cassandra</a></li> <li><a href="/docs/kafka" class="">Kafka</a></li></ul></li> <li><a href="/docs/related/" class="">Related Work</a> <ul class="sub_section"> <li><a href="/docs/related/#bibliography" class="">Bibliography</a></li> <li><a href="/docs/related/#Scala" class="">Scala Libraries</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/frees-io/freestyle"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/frees-io/freestyle"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Freestyle A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Freestyle A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="frees-io" data-github-repo="freestyle"><div class="content-wrapper"><section><h1 id="handlers">Handlers</h1>

<p>Freestyle empowers programs whose runtime can easily be overridden via implicit evidence.</p>

<p>As part of its design, Freestyle is compatible with <code class="highlighter-rouge">Free</code> and the traditional patterns around it. Apps built with Freestyle give developers the freedom to choose automatic or manual algebras, modules, and interpreters, and intermix them as you see fit in applications based on the desired encoding.</p>

<h2 id="implementation">Implementation</h2>

<p>Freestyle automatically generates an abstract definition of an interpreter for each one of the
algebras annotated with <code class="highlighter-rouge">@free</code>.
This allows you to build the proper runtime definitions for your algebras by simply extending the <code class="highlighter-rouge">Handler[M[_]]</code>
member in your algebras companion.</p>

<p>Consider the following algebra adapted to Freestyle from the <a href="http://typelevel.org/cats/datatypes/freemonad.html">Typelevel Cats Free monads examples</a>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.free._</span>
<span class="c1">// import freestyle.free._
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="nd">@free</span> <span class="k">trait</span> <span class="nc">KVStore</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS.Seq</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">get</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="o">).</span><span class="n">freeS</span> <span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">put</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)).</span><span class="n">freeS</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">().</span><span class="n">pure</span><span class="o">[</span><span class="kt">FS.Seq</span><span class="o">]</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// defined trait KVStore
// defined object KVStore
</span></code></pre>
</div>

<p>To define a runtime interpreter for this, we simply extend <code class="highlighter-rouge">KVStore.Handler[M[_]]</code> and implement its abstract members:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.State</span>
<span class="c1">// import cats.data.State
</span>
<span class="k">type</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias KVStoreState
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">kvStoreHandler</span><span class="k">:</span> <span class="kt">KVStore.Handler</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">.</span><span class="nc">Handler</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]))</span>
  <span class="k">def</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">key</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// kvStoreHandler: KVStore.Handler[KVStoreState] = $anon$1@d5c4c3a
</span></code></pre>
</div>

<p>As you may have noticed, instead of implementing a Natural transformation <code class="highlighter-rouge">F ~&gt; M</code>, we implement methods that closely resemble each one of the smart constructors in our <code class="highlighter-rouge">@free</code> algebras in Freestyle. This is not an imposition but rather a convenience as the resulting instances are still Natural Transformations.</p>

<p>In the example above, <code class="highlighter-rouge">KVStore.Handler[M[_]]</code> is already a Natural transformation of type <code class="highlighter-rouge">KVStore.Op ~&gt; KVStoreState</code> in which its
<code class="highlighter-rouge">apply</code> function automatically delegates each step to the abstract method that you are implementing as part of the Handler.</p>

<p>Alternatively, if you would rather implement a natural transformation by hand, you can still do that by choosing not to implement
<code class="highlighter-rouge">KVStore.Handler[M[_]]</code> and providing one like so:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">~&gt;</span>
<span class="c1">// import cats.$tilde$greater
</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">manualKvStoreHandler</span><span class="k">:</span> <span class="kt">KVStore.Op</span> <span class="kt">~&gt;</span> <span class="kt">KVStoreState</span> <span class="o">=</span> 
  <span class="k">new</span> <span class="o">(</span><span class="nc">KVStore</span><span class="o">.</span><span class="nc">Op</span> <span class="o">~&gt;</span> <span class="nc">KVStoreState</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">KVStore.Op</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">KVStore</span><span class="o">.</span><span class="nc">PutOp</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">))</span>
        <span class="k">case</span> <span class="nc">KVStore</span><span class="o">.</span><span class="nc">GetOp</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">State</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]))</span>
        <span class="k">case</span> <span class="nc">KVStore</span><span class="o">.</span><span class="nc">DeleteOp</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">key</span><span class="o">)</span>
      <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// manualKvStoreHandler: KVStore.Op ~&gt; KVStoreState
</span></code></pre>
</div>

<h2 id="composition">Composition</h2>

<p>Freestyle performs automatic composition of interpreters by providing the implicit machinery necessary to derive a Module interpreter
by the evidence of it’s algebras’ interpreters.
To illustrate interpreter composition, let’s define a new algebra <code class="highlighter-rouge">Log</code> which we will compose with our <code class="highlighter-rouge">KVStore</code> operations:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nd">@free</span> <span class="k">trait</span> <span class="nc">Log</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">info</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">warn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
<span class="c1">// defined trait Log
// defined object Log
</span></code></pre>
</div>

<p>Once our algebra is defined we can easily write an interpreter for it:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">logHandler</span><span class="k">:</span> <span class="kt">Log.Handler</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Log</span><span class="o">.</span><span class="nc">Handler</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">info</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"INFO: $msg"</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">warn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">KVStoreState</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"WARN: $msg"</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span>
  <span class="o">}</span>
<span class="c1">// logHandler: Log.Handler[KVStoreState]
</span></code></pre>
</div>

<p>Before we create a program combining all operations, let’s consider both <code class="highlighter-rouge">KVStore</code> and <code class="highlighter-rouge">Log</code> as part of a module in our application:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nd">@module</span> <span class="k">trait</span> <span class="nc">Backend</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">store</span><span class="k">:</span> <span class="kt">KVStore</span>
  <span class="k">val</span> <span class="n">log</span><span class="k">:</span> <span class="kt">Log</span>
<span class="o">}</span>
<span class="c1">// defined trait Backend
// defined object Backend
</span></code></pre>
</div>

<p>When <code class="highlighter-rouge">@module</code> is materialized, it will automatically create the <code class="highlighter-rouge">Coproduct</code> that matches the interpreters necessary to run the <code class="highlighter-rouge">Free</code> structure
below:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Backend</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">B.store._</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="k">_</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">put</span><span class="o">(</span><span class="s">"wild-cats"</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">info</span><span class="o">(</span><span class="s">"Added wild-cats"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">update</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"wild-cats"</span><span class="o">,</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">12</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">info</span><span class="o">(</span><span class="s">"Updated wild-cats"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">put</span><span class="o">(</span><span class="s">"tame-cats"</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">get</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"wild-cats"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">delete</span><span class="o">(</span><span class="s">"tame-cats"</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">warn</span><span class="o">(</span><span class="s">"Deleted tame-cats"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
<span class="o">}</span>
<span class="c1">// program: [F[_]](implicit B: Backend[F])freestyle.free.FreeS[F,Option[Int]]
</span></code></pre>
</div>

<p>Once we have combined our algebras, we can evaluate them by providing implicit evidence of the Coproduct interpreters. <code class="highlighter-rouge">import freestyle.free.implicits._</code> brings into scope, among others, the necessary implicit definitions to derive a unified interpreter given implicit evidence of each one of the individual algebra’s interpreters:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.free.implicits._</span>
<span class="c1">// import freestyle.free.implicits._
</span>
<span class="n">program</span><span class="o">[</span><span class="kt">Backend.Op</span><span class="o">].</span><span class="n">interpret</span><span class="o">[</span><span class="kt">KVStoreState</span><span class="o">]</span>
<span class="c1">// res0: KVStoreState[Option[Int]] = cats.data.IndexedStateT@3d38e397
</span></code></pre>
</div>

<p>Alternatively, you can build your interpreters by hand if you choose not to use Freestyle’s implicit machinery. This can quickly grow unruly as the number of algebras increase in an application, but it’s also possible, in the spirit of providing two-way compatibility in all areas between manually built ADTs and Natural Transformations, and the ones automatically derived by Freestyle.</p>

<h2 id="tagless-interpretation">Tagless Interpretation</h2>

<p>Some imports:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">freestyle.tagless._</span>
</code></pre>
</div>

<p>Tagless final algebras are declared using the <code class="highlighter-rouge">@tagless</code> macro annotation.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nd">@tagless</span> <span class="k">trait</span> <span class="nc">Validation</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">minSize</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">hasNumber</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>
<span class="c1">// defined trait Validation
// defined object Validation
</span>
<span class="nd">@tagless</span> <span class="k">trait</span> <span class="nc">Interaction</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">ask</span><span class="o">(</span><span class="n">prompt</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">FS</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span>
<span class="c1">// defined trait Interaction
// defined object Interaction
</span></code></pre>
</div>

<p>Once your <code class="highlighter-rouge">@tagless</code> algebras are defined, you can start building programs that rely upon implicit evidence of those algebras
being present, for the target runtime monad you are planning to interpret to.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">taglessProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="k">implicit</span> <span class="n">validation</span> <span class="k">:</span> <span class="kt">Validation</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">interaction</span><span class="k">:</span> <span class="kt">Interaction</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">userInput</span> <span class="k">&lt;-</span> <span class="n">interaction</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="s">"Give me something with at least 3 chars and a number on it"</span><span class="o">)</span>
    <span class="n">valid</span>     <span class="k">&lt;-</span> <span class="o">(</span><span class="n">validation</span><span class="o">.</span><span class="n">minSize</span><span class="o">(</span><span class="n">userInput</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="n">validation</span><span class="o">.</span><span class="n">hasNumber</span><span class="o">(</span><span class="n">userInput</span><span class="o">)).</span><span class="n">mapN</span><span class="o">(</span><span class="k">_</span> <span class="o">&amp;&amp;</span> <span class="k">_</span><span class="o">)</span>
    <span class="k">_</span>         <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">)</span>
                    <span class="n">interaction</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="s">"awesomesauce!"</span><span class="o">)</span> 
                 <span class="k">else</span>
                    <span class="n">interaction</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">s</span><span class="s">"$userInput is not valid"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
<span class="c1">// taglessProgram: [F[_]](implicit evidence$1: cats.Monad[F], implicit validation: Validation[F], implicit interaction: Interaction[F])interaction.FS[Unit]
</span></code></pre>
</div>

<p>Note that unlike in <code class="highlighter-rouge">@free</code>, <code class="highlighter-rouge">F[_]</code> here refers to the target runtime monad. This is to provide an allocation free model where your
ops are not being reified and then interpreted. This allocation step in Free monads is what allows them to be stack-safe.
The tagless final encoding with direct style syntax is as stack-safe as the target <code class="highlighter-rouge">F[_]</code> you are interpreting to.</p>

<p>Once our <code class="highlighter-rouge">@tagless</code> algebras are defined, we can provide <code class="highlighter-rouge">Handler</code> instances in the same way we do with <code class="highlighter-rouge">@free</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="c1">// import scala.util.Try
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">validationHandler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Validation</span><span class="o">.</span><span class="nc">Handler</span><span class="o">[</span><span class="kt">Try</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">minSize</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hasNumber</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="s">"0123456789"</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">c</span><span class="o">)))</span>
<span class="o">}</span>
<span class="c1">// validationHandler: Validation.Handler[scala.util.Try] = $anon$1@5026f646
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">interactionHandler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Interaction</span><span class="o">.</span><span class="nc">Handler</span><span class="o">[</span><span class="kt">Try</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">tell</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">ask</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="s">"This could have been user input 1"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// interactionHandler: Interaction.Handler[scala.util.Try] = $anon$1@73bbb3b6
</span></code></pre>
</div>

<p>At this point, we can run our pure programs at the edge of the world.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">taglessProgram</span><span class="o">[</span><span class="kt">Try</span><span class="o">]</span>
<span class="c1">// awesomesauce!
// res2: interactionHandler.FS[Unit] = Success(())
</span></code></pre>
</div>

<h2 id="stack-safety">Stack Safety</h2>

<p>Freestyle provides two strategies to make <code class="highlighter-rouge">@tagless</code> encoded algebras stack safe.</p>

<h3 id="interpreting-to-a-stack-safe-monad">Interpreting to a stack safe monad</h3>

<p>The handlers above are not stack safe because <code class="highlighter-rouge">Try</code> is not stack-safe. Luckily, we can still execute 
our program stack safe with Freestyle by interpreting to <code class="highlighter-rouge">Free[Try, ?]</code> instead of <code class="highlighter-rouge">Try</code> directly. 
This small penalty and a few extra allocations will make our programs stack safe.</p>

<p>We can safely invoke our program in a stack safe way, running it first to <code class="highlighter-rouge">Free[Try, ?]</code> then to <code class="highlighter-rouge">Try</code> with <code class="highlighter-rouge">Free#runTailRec</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">cats.free.Free</span>
<span class="k">import</span> <span class="nn">cats.free.Free</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">taglessProgram</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">Try</span>, <span class="kt">?</span><span class="o">]].</span><span class="n">runTailRec</span>
<span class="n">awesomesauce</span><span class="o">!</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Success</span><span class="o">(())</span>
</code></pre>
</div>

<h3 id="interpreting-combined-tagless-and-free-algebras">Interpreting combined <code class="highlighter-rouge">@tagless</code> and <code class="highlighter-rouge">@free</code> algebras</h3>

<p>When combining <code class="highlighter-rouge">@tagless</code> and <code class="highlighter-rouge">@free</code> algebras, we need all algebras to be considered in the final Coproduct we are interpreting to.
We can simply use tagless’ <code class="highlighter-rouge">.StackSafe</code> representation in modules so they are considered for the final Coproduct.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.free._</span>
<span class="k">import</span> <span class="nn">freestyle.free.implicits._</span>

<span class="k">import</span> <span class="nn">freestyle.free.logging._</span>
<span class="k">import</span> <span class="nn">freestyle.free.loggingJVM.implicits._</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">taglessProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
   <span class="o">(</span><span class="k">implicit</span> <span class="n">log</span><span class="k">:</span> <span class="kt">LoggingM</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> 
             <span class="n">validation</span> <span class="k">:</span> <span class="kt">Validation.StackSafe</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> 
             <span class="n">interaction</span><span class="k">:</span> <span class="kt">Interaction.StackSafe</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">cats.implicits._</span>

  <span class="k">for</span> <span class="o">{</span>
    <span class="n">userInput</span> <span class="k">&lt;-</span> <span class="n">interaction</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="s">"Give me something with at least 3 chars and a number on it"</span><span class="o">)</span>
    <span class="n">valid</span>     <span class="k">&lt;-</span> <span class="o">(</span><span class="n">validation</span><span class="o">.</span><span class="n">minSize</span><span class="o">(</span><span class="n">userInput</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="n">validation</span><span class="o">.</span><span class="n">hasNumber</span><span class="o">(</span><span class="n">userInput</span><span class="o">)).</span><span class="n">mapN</span><span class="o">(</span><span class="k">_</span> <span class="o">&amp;&amp;</span> <span class="k">_</span><span class="o">)</span>
    <span class="k">_</span>         <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">)</span>
                    <span class="n">interaction</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="s">"awesomesauce!"</span><span class="o">)</span> 
                 <span class="k">else</span>
                    <span class="n">interaction</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">s</span><span class="s">"$userInput is not valid"</span><span class="o">)</span>
    <span class="k">_</span>         <span class="k">&lt;-</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">"Program finished"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
<span class="o">}</span>
<span class="c1">// taglessProgram: [F[_]](implicit log: freestyle.free.logging.LoggingM[F], implicit validation: Validation.StackSafe[F], implicit interaction: Interaction.StackSafe[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Unit]
</span></code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nd">@module</span> <span class="k">trait</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">interaction</span><span class="k">:</span> <span class="kt">Interaction.StackSafe</span>
  <span class="k">val</span> <span class="n">validation</span><span class="k">:</span> <span class="kt">Validation.StackSafe</span>
  <span class="k">val</span> <span class="n">log</span><span class="k">:</span> <span class="kt">LoggingM</span>
<span class="o">}</span>
<span class="c1">// defined trait App
// defined object App
</span></code></pre>
</div>

<p>Once all of our algebras are considered, we can execute our programs:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">taglessProgram</span><span class="o">[</span><span class="kt">App.Op</span><span class="o">].</span><span class="n">interpret</span><span class="o">[</span><span class="kt">Try</span><span class="o">]</span>
<span class="c1">// awesomesauce!
// res5: scala.util.Try[Unit] = Success(())
</span></code></pre>
</div>

<p>Now that we’ve learned to define our own interpreters, let’s jump into <a href="../parallelism/">Parallelism</a>.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/js/animations.js"></script><script src="/js/anime.min.js"></script><script>((window.gitter = {}).chat = {}).options = {
room: '47deg/freestyle'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/js/main.js"></script></body></html>
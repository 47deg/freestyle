<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>Freestyle</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries" /><meta name="author" content="47 Degrees" /><meta name="og:image" content="/img/poster.png" /><meta name="og:title" content="Freestyle" /><meta name="og:site_name" content="Freestyle" /><meta name="og:url" content="https://47deg.github.io/docs/" /><meta name="og:type" content="website" /><meta name="og:description" content="A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries" /><meta name="twitter:image" content="/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><meta name="kazari-dependencies" content="com.47deg;freestyle_2.12;0.1.0-SNAPSHOT,org.scalamacros;paradise_2.12.1;2.1.0" /><meta name="kazari-resolvers" content="https://oss.sonatype.org/content/repositories/snapshots,https://oss.sonatype.org/content/repositories/releases" /><link rel="icon" type="image/png" href="/img/favicon.png" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/dracula.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /><link rel="stylesheet" href="/css/kazari-style.css" /><link rel="stylesheet" href="/css/dracula.css" /><link rel="stylesheet" href="/css/custom.css" /><link rel="stylesheet" href="/css/dracula.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>Freestyle</span></div></a></li> <li><a href="/docs/" class="">Quick Start</a></li> <li><a href="/docs/algebras/" class="">Algebras</a></li> <li><a href="/docs/modules/" class="">Modules</a></li> <li><a href="/docs/interpreters/" class="">Handlers</a></li> <li><a href="/docs/parallelism/" class="">Parallelism</a></li> <li><a href="/docs/effects/" class=" active ">Effects</a> <ul class="sub_section"> <li><a href="/docs/effects/#Error" class="">Error</a></li> <li><a href="/docs/effects/#Option" class="">Option</a></li> <li><a href="/docs/effects/#Reader" class="">Reader</a></li> <li><a href="/docs/effects/#Writer" class="">Writer</a></li> <li><a href="/docs/effects/#State" class="">State</a></li> <li><a href="/docs/effects/#Traverse" class="">Traverse</a></li> <li><a href="/docs/effects/#Validation" class="">Validation</a></li></ul></li> <li><a href="/docs/stack/" class="">Example Target Stack</a></li> <li><a href="/TODO.html" class="">Patterns</a> <ul class="sub_section"> <li><a href="/docs/effects/Cache/" class="">Cache</a></li> <li><a href="/TODO.html" class="">Dependency Injection</a></li> <li><a href="/TODO.html" class="">Configuration</a></li> <li><a href="/TODO.html" class="">Logging</a></li></ul></li> <li><a href="/TODO.html" class="">Integrations</a> <ul class="sub_section"> <li><a href="/docs/cats" class="">Cats</a></li> <li><a href="/TODO.html" class="">Monix</a></li> <li><a href="/docs/fetch" class="">Fetch</a></li> <li><a href="/docs/fs2" class="">FS2</a></li> <li><a href="/docs/doobie" class="">Doobie</a></li> <li><a href="/docs/slick" class="">Slick</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/47deg/freestyle"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/47deg/freestyle"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Freestyle A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Freestyle A Cohesive &amp; Pragmatic Framework of FP centric Scala libraries');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="47deg" data-github-repo="freestyle"><div class="content-wrapper"><section><h1 id="effects">Effects</h1>

<p>Freestyle comes builtin with a list of ready to use effects modeled as <code class="highlighter-rouge">@free</code> algebras contained in the <code class="highlighter-rouge">freestyle-effects</code> module.
The current release of <code class="highlighter-rouge">freestyle-effects</code> supports Scala.jvm and Scala.js.</p>

<p>For Scala.jvm</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"io.freestyle"</span> <span class="o">%%</span> <span class="s">"freestyle-effects"</span> <span class="o">%</span> <span class="s">"0.1.0"</span>
</code></pre>
</div>

<p>For Scala.js</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"io.freestyle"</span> <span class="o">%%%</span> <span class="s">"freestyle-effects"</span> <span class="o">%</span> <span class="s">"0.1.0"</span>
</code></pre>
</div>

<p>If you are missing an effect from the following list please <a href="https://github.com/47deg/freestyle/issues/new">raise an issue</a>
so it can be considered in future releases.</p>

<ul>
  <li><a href="#error">error</a></li>
  <li><a href="#option">option</a></li>
  <li><a href="#reader">reader</a></li>
  <li><a href="#writer">writer</a></li>
  <li><a href="#state">state</a></li>
  <li><a href="#traverse">traverse</a></li>
  <li><a href="#validation">validation</a></li>
</ul>

<h2 id="error">Error</h2>

<p>The error effect allows short circuiting of programs and handling invocations which can potentially result in runtime exceptions.
It includes three basic operations <code class="highlighter-rouge">either</code>, <code class="highlighter-rouge">error</code> and <code class="highlighter-rouge">catchNonFatal</code>.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadError[M[_], Throwable]</code> 
for <code class="highlighter-rouge">Target</code> or any other runtime <code class="highlighter-rouge">M[_]</code> used in interpretation. In the example below this constrain is satisfied by
<code class="highlighter-rouge">import cats.implicits._</code> which provides a <code class="highlighter-rouge">MonadError</code> instance for <code class="highlighter-rouge">Either[Throwable, ?]</code>. 
Multiple types such as <code class="highlighter-rouge">Future</code>, <code class="highlighter-rouge">monix.eval.Task</code> and even more complex transformers stacks are capable of satisfying these constrains.</p>

<h3 id="either">either</h3>

<p><code class="highlighter-rouge">either</code> allows us to lift values of <code class="highlighter-rouge">Either[Throwable, ?]</code> into the context of <code class="highlighter-rouge">FreeS</code> raising an error short circuiting 
the program if the value is a <code class="highlighter-rouge">Left(throwable)</code> or continuing with the computation in the case of a <code class="highlighter-rouge">Right(a)</code></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle._</span>
<span class="c1">// import freestyle._
</span>
<span class="k">import</span> <span class="nn">freestyle.implicits._</span>
<span class="c1">// import freestyle.implicits._
</span>
<span class="k">import</span> <span class="nn">freestyle.effects.error._</span>
<span class="c1">// import freestyle.effects.error._
</span>
<span class="k">import</span> <span class="nn">freestyle.effects.error.implicits._</span>
<span class="c1">// import freestyle.effects.error.implicits._
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">val</span> <span class="n">boom</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"BOOM"</span><span class="o">)</span>
<span class="c1">// boom: RuntimeException = java.lang.RuntimeException: BOOM
</span>
<span class="k">type</span> <span class="kt">Target</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias Target
</span>
<span class="k">def</span> <span class="n">shortCircuit</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">ErrorM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">either</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Left</span><span class="o">(</span><span class="n">boom</span><span class="o">))</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// shortCircuit: [F[_]](implicit evidence$1: freestyle.effects.error.ErrorM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">shortCircuit</span><span class="o">[</span><span class="kt">ErrorM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Target</span><span class="o">]</span>
<span class="c1">// res0: Target[Int] = Left(java.lang.RuntimeException: BOOM)
</span></code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">continueWithRightValue</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">ErrorM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">either</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Right</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// continueWithRightValue: [F[_]](implicit evidence$1: freestyle.effects.error.ErrorM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">continueWithRightValue</span><span class="o">[</span><span class="kt">ErrorM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Target</span><span class="o">]</span>
<span class="c1">// res1: Target[Int] = Right(3)
</span></code></pre>
</div>

<h3 id="error-1">error</h3>

<p>If you want so simply raise an error without throwing an exception you may use the <code class="highlighter-rouge">error</code> operation which short circuits
the program.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">shortCircuitWithError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">ErrorM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">boom</span><span class="o">)</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// shortCircuitWithError: [F[_]](implicit evidence$1: freestyle.effects.error.ErrorM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">shortCircuitWithError</span><span class="o">[</span><span class="kt">ErrorM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Target</span><span class="o">]</span>
<span class="c1">// res2: Target[Int] = Left(java.lang.RuntimeException: BOOM)
</span></code></pre>
</div>

<h3 id="catchnonfatal">catchNonFatal</h3>

<p><code class="highlighter-rouge">catchNonFatal</code> allows capturing of exception in computations that are not guaranteed to succeed and may potentially throw
a runtime exception when interacting with unprincipled APIs which signal errors as thrown exceptions.
Not all subclass of <code class="highlighter-rouge">java.lang.Throwable</code> are captured by <code class="highlighter-rouge">catchNonFatal</code>, as its name implies just those that are considered
in <code class="highlighter-rouge">scala.util.control.NonFatal</code>.</p>

<p><code class="highlighter-rouge">catchNonFatal</code> expects a <code class="highlighter-rouge">cats.Eval</code> value which holds a lazy computation.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Eval</span>
<span class="c1">// import cats.Eval
</span>
<span class="k">def</span> <span class="n">catchingExceptions</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">ErrorM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">catchNonFatal</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Eval</span><span class="o">.</span><span class="n">later</span><span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">))</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// catchingExceptions: [F[_]](implicit evidence$1: freestyle.effects.error.ErrorM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">catchingExceptions</span><span class="o">[</span><span class="kt">ErrorM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Target</span><span class="o">]</span>
<span class="c1">// res3: Target[Int] = Left(java.lang.RuntimeException)
</span></code></pre>
</div>

<h2 id="option">Option</h2>

<p>The option effect allows short circuiting of programs for optional values.
It includes two basic operations: <code class="highlighter-rouge">option</code> and <code class="highlighter-rouge">non</code>.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadFilter[M[_]] 
for any runtime </code>M[<em>]<code class="highlighter-rouge"> used in its interpretation. Short-circuiting with </code>none<code class="highlighter-rouge"> does not mean that you'd end up with a
</code>None<code class="highlighter-rouge"> value at some point. The final value in case of short-circuit is determined by the </code>MonadFilter[M[</em>]]#empty<code class="highlighter-rouge"> for 
your target runtime </code>M[_]`.</p>

<h3 id="option-1">option</h3>

<p><code class="highlighter-rouge">option</code> allows a value of type <code class="highlighter-rouge">Option[_]</code> to be lifted into the context of <code class="highlighter-rouge">FreeS</code>. If a <code class="highlighter-rouge">None</code> it’s found the program
will short circuit.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects.option._</span>
<span class="c1">// import freestyle.effects.option._
</span>
<span class="k">import</span> <span class="nn">freestyle.effects.option.implicits._</span>
<span class="c1">// import freestyle.effects.option.implicits._
</span>
<span class="k">def</span> <span class="n">programNone</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">OptionM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">OptionM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">option</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">None</span><span class="o">)</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programNone: [F[_]](implicit evidence$1: freestyle.effects.option.OptionM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programNone</span><span class="o">[</span><span class="kt">OptionM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span>
<span class="c1">// res4: Option[Int] = None
</span></code></pre>
</div>

<p>If a <code class="highlighter-rouge">Some(_)</code> is found the value is extracted and lifted into the context and the programs resumes
normally.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programSome</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">OptionM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">OptionM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">option</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programSome: [F[_]](implicit evidence$1: freestyle.effects.option.OptionM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programSome</span><span class="o">[</span><span class="kt">OptionM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span>
<span class="c1">// res5: Option[Int] = Some(3)
</span></code></pre>
</div>

<h3 id="none">none</h3>

<p><code class="highlighter-rouge">none</code> immediately short circuits the program without providing further information as to what the reason is. Handle with
care.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programNone2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">OptionM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">OptionM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">none</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programNone2: [F[_]](implicit evidence$1: freestyle.effects.option.OptionM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programNone2</span><span class="o">[</span><span class="kt">OptionM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span>
<span class="c1">// res6: Option[Int] = None
</span></code></pre>
</div>

<h2 id="reader">Reader</h2>

<p>The reader effect allows obtaining values from the environment. The initial seed for the environment value is provided
at runtime interpretation.</p>

<p>The <code class="highlighter-rouge">reader</code> effect supports parametrization to any seed value type while remaining type safe throughout the program declaration.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadReader[M[_], R]</code> 
for any runtime <code class="highlighter-rouge">M[_]</code> used in its interpretation. <code class="highlighter-rouge">R</code> represents the seed value type.</p>

<p>The reader effect comes with two operations <code class="highlighter-rouge">ask</code> and <code class="highlighter-rouge">reader</code>.</p>

<h3 id="ask">ask</h3>

<p><code class="highlighter-rouge">ask</code> simply returns the entire environment in its current state.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects.reader</span>
<span class="c1">// import freestyle.effects.reader
</span>
<span class="k">import</span> <span class="nn">cats.data.Reader</span>
<span class="c1">// import cats.data.Reader
</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Config</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Config
</span>
<span class="k">type</span> <span class="kt">ConfigEnv</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">Config</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias ConfigEnv
</span>
<span class="k">val</span> <span class="n">rd</span> <span class="k">=</span> <span class="n">reader</span><span class="o">[</span><span class="kt">Config</span><span class="o">]</span>
<span class="c1">// rd: freestyle.effects.reader.EnvironmentProvider[Config] = freestyle.effects.reader$EnvironmentProvider@5df06661
</span>
<span class="k">import</span> <span class="nn">rd.implicits._</span>
<span class="c1">// import rd.implicits._
</span>
<span class="k">def</span> <span class="n">programAsk</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">rd.ReaderM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">rd</span><span class="o">.</span><span class="nc">ReaderM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">ask</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">c</span>
<span class="c1">// programAsk: [F[_]](implicit evidence$1: rd.ReaderM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Config]
</span>
<span class="n">programAsk</span><span class="o">[</span><span class="kt">rd.ReaderM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ConfigEnv</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="nc">Config</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">10</span><span class="o">))</span>
<span class="c1">// res7: cats.Id[Config] = Config(10)
</span></code></pre>
</div>

<h3 id="reader-1">reader</h3>

<p><code class="highlighter-rouge">reader</code> allows extracting values of the environment and lifting them into the context of <code class="highlighter-rouge">FreeS</code></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programReader</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">rd.ReaderM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">rd</span><span class="o">.</span><span class="nc">ReaderM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">reader</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programReader: [F[_]](implicit evidence$1: rd.ReaderM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programReader</span><span class="o">[</span><span class="kt">rd.ReaderM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ConfigEnv</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="nc">Config</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">1</span><span class="o">))</span>
<span class="c1">// res8: cats.Id[Int] = 3
</span></code></pre>
</div>

<h2 id="writer">Writer</h2>

<p>The writer effect allows to accumulate values which can be obtained once the program is interpreted.</p>

<p>The <code class="highlighter-rouge">writer</code> effect supports parametrization to any type that supports monoidal accumulation while remaining type safe throughout the program declaration.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadWriter[M[_], W]</code> 
for any runtime <code class="highlighter-rouge">M[_]</code> used in its interpretation.</p>

<p>The writer effect comes with two operations <code class="highlighter-rouge">writer</code> and <code class="highlighter-rouge">tell</code>.</p>

<h3 id="writer-1">writer</h3>

<p><code class="highlighter-rouge">writer</code> sets a tuple with the current accumulator value and returning value</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects.writer</span>
<span class="c1">// import freestyle.effects.writer
</span>
<span class="k">import</span> <span class="nn">cats.data.Writer</span>
<span class="c1">// import cats.data.Writer
</span>
<span class="k">val</span> <span class="n">wr</span> <span class="k">=</span> <span class="n">writer</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
<span class="c1">// wr: freestyle.effects.writer.AccumulatorProvider[List[Int]] = freestyle.effects.writer$AccumulatorProvider@7a0de8ef
</span>
<span class="k">import</span> <span class="nn">wr.implicits._</span>
<span class="c1">// import wr.implicits._
</span>
<span class="k">type</span> <span class="kt">Logger</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Writer</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias Logger
</span>
<span class="k">def</span> <span class="n">programWriter</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">wr.WriterM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">wr</span><span class="o">.</span><span class="nc">WriterM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">writer</span><span class="o">((</span><span class="nc">Nil</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="c1">// programWriter: [F[_]](implicit evidence$1: wr.WriterM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programWriter</span><span class="o">[</span><span class="kt">wr.WriterM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Logger</span><span class="o">].</span><span class="n">run</span>
<span class="c1">// res9: cats.Id[(List[Int], Int)] = (List(),1)
</span></code></pre>
</div>

<h3 id="tell">tell</h3>

<p><code class="highlighter-rouge">tell</code> appends a value for monoidal accumulation</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programTell</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">wr.WriterM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">wr</span><span class="o">.</span><span class="nc">WriterM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">writer</span><span class="o">((</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="mi">1</span><span class="o">))</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">wr</span><span class="o">.</span><span class="nc">WriterM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">tell</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="c1">// programTell: [F[_]](implicit evidence$1: wr.WriterM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programTell</span><span class="o">[</span><span class="kt">wr.WriterM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">Logger</span><span class="o">].</span><span class="n">run</span>
<span class="c1">// res10: cats.Id[(List[Int], Int)] = (List(1, 1),1)
</span></code></pre>
</div>

<h2 id="state">State</h2>

<p>The state effect enables purely functional state throughout programs.</p>

<p>The <code class="highlighter-rouge">state</code> effect supports parametrization to any type remaining type safe throughout the program declaration.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadState[M[_], S]</code> 
for any runtime <code class="highlighter-rouge">M[_]</code> where <code class="highlighter-rouge">S</code> is the type of state.</p>

<p>The state effect comes with four basic operations <code class="highlighter-rouge">get</code>, <code class="highlighter-rouge">set</code>, <code class="highlighter-rouge">modify</code> and <code class="highlighter-rouge">inspect</code>.</p>

<h2 id="get">get</h2>

<p><code class="highlighter-rouge">get</code> retrieves the current state</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects.state</span>
<span class="c1">// import freestyle.effects.state
</span>
<span class="k">import</span> <span class="nn">cats.data.State</span>
<span class="c1">// import cats.data.State
</span>
<span class="k">val</span> <span class="n">st</span> <span class="k">=</span> <span class="n">state</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="c1">// st: freestyle.effects.state.StateSeedProvider[Int] = freestyle.effects.state$StateSeedProvider@550d9312
</span>
<span class="k">type</span> <span class="kt">TargetState</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias TargetState
</span>
<span class="k">import</span> <span class="nn">st.implicits._</span>
<span class="c1">// import st.implicits._
</span>
<span class="k">def</span> <span class="n">programGet</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">st.StateM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">get</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programGet: [F[_]](implicit evidence$1: st.StateM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programGet</span><span class="o">[</span><span class="kt">st.StateM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">TargetState</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// res11: (Int, Int) = (1,3)
</span></code></pre>
</div>

<h3 id="set">set</h3>

<p><code class="highlighter-rouge">set</code> replaces the current state</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programSet</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">st.StateM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">set</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">get</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
<span class="c1">// programSet: [F[_]](implicit evidence$1: st.StateM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programSet</span><span class="o">[</span><span class="kt">st.StateM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">TargetState</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// res12: (Int, Int) = (1,1)
</span></code></pre>
</div>

<h3 id="modify">modify</h3>

<p><code class="highlighter-rouge">modify</code> modifies the current state</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programModify</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">st.StateM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">get</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">get</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="c1">// programModify: [F[_]](implicit evidence$1: st.StateM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programModify</span><span class="o">[</span><span class="kt">st.StateM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">TargetState</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// res13: (Int, Int) = (2,2)
</span></code></pre>
</div>

<h3 id="inspect">inspect</h3>

<p><code class="highlighter-rouge">inspect</code> runs a function over the current state and returns the resulting value</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programInspect</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">st.StateM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">get</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">st</span><span class="o">.</span><span class="nc">StateM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="c1">// programInspect: [F[_]](implicit evidence$1: st.StateM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programInspect</span><span class="o">[</span><span class="kt">st.StateM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">TargetState</span><span class="o">].</span><span class="n">run</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// res14: (Int, Int) = (1,2)
</span></code></pre>
</div>

<h2 id="traverse">Traverse</h2>

<p>Traverse acts as a generator and works with any <code class="highlighter-rouge">G[_]</code> for which a <code class="highlighter-rouge">cats.Foldable</code> instance is available.
The target runtime <code class="highlighter-rouge">M[_]</code> requires a <code class="highlighter-rouge">MonadCombine[M]</code> instance.</p>

<p>Traverse includes two basic operations <code class="highlighter-rouge">fromTraversable</code> and <code class="highlighter-rouge">empty</code></p>

<h3 id="fromtraversable">fromTraversable</h3>

<p><code class="highlighter-rouge">fromTraversable</code> allows lifting of any <code class="highlighter-rouge">G[_]: Foldable</code> into the context of <code class="highlighter-rouge">FreeS</code></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects._</span>
<span class="c1">// import freestyle.effects._
</span>
<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
<span class="c1">// list: freestyle.effects.traverse.TraverseProvider[List] = freestyle.effects.traverse$TraverseProvider@1467b78f
</span>
<span class="k">import</span> <span class="nn">list._</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">implicits</span><span class="o">.</span><span class="k">_</span>
<span class="c1">// import list._
// import list.implicits._
</span>
<span class="k">def</span> <span class="n">programTraverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">TraverseM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">TraverseM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromTraversable</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="c1">// programTraverse: [F[_]](implicit evidence$1: list.TraverseM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programTraverse</span><span class="o">[</span><span class="kt">TraverseM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
<span class="c1">// res15: List[Int] = List(2, 3, 4)
</span></code></pre>
</div>

<h3 id="empty">empty</h3>

<p><code class="highlighter-rouge">empty</code> allows short circuiting of programs providing the empty value for the <code class="highlighter-rouge">G[_]</code> through the final <code class="highlighter-rouge">MonadCombine</code>.
In the same way as <code class="highlighter-rouge">OptionM#none</code>, the empty value is determined by how the <code class="highlighter-rouge">MonadCombine</code> instance for the final <code class="highlighter-rouge">M[_]</code>
is implemented.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programEmpty</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">TraverseM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">TraverseM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">TraverseM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromTraversable</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">c</span>
<span class="c1">// programEmpty: [F[_]](implicit evidence$1: list.TraverseM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programEmpty</span><span class="o">[</span><span class="kt">TraverseM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
<span class="c1">// res16: List[Int] = List()
</span></code></pre>
</div>

<h2 id="validation">Validation</h2>

<p>The validation effect allows for the distinction between valid and invalid values in a program, accumulating the validation errors when executing it.</p>

<p>The <code class="highlighter-rouge">validation</code> effect, like <a href="#state">state</a>, supports parametrization to any type remaining type safe throughout the program declaration.</p>

<p>The constrains placed by this effect is that there needs to be an implicit evidence of <code class="highlighter-rouge">MonadState[M[_], List[E]]</code>
for any runtime <code class="highlighter-rouge">M[_]</code> where <code class="highlighter-rouge">E</code> is the type of the validation error.</p>

<p>The validation effect comes with three basic operations <code class="highlighter-rouge">valid</code>, <code class="highlighter-rouge">invalid</code>, and <code class="highlighter-rouge">errors</code>. Apart from that, it includes a couple of combinators for accumulating errors: <code class="highlighter-rouge">fromEither</code> and <code class="highlighter-rouge">fromValidatedNel</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">freestyle.effects.validation</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ValidationError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NotValid</span><span class="o">(</span><span class="n">explanation</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ValidationError</span>

<span class="k">val</span> <span class="n">vl</span> <span class="k">=</span> <span class="n">validation</span><span class="o">[</span><span class="kt">ValidationError</span><span class="o">]</span>
<span class="k">import</span> <span class="nn">vl.implicits._</span>

<span class="k">type</span> <span class="kt">ValidationResult</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">ValidationError</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre>
</div>

<h3 id="valid">valid</h3>

<p><code class="highlighter-rouge">valid</code> lifts a valid value to the program without accumulating any errors.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="c1">// import cats.instances.list._
</span>
<span class="k">def</span> <span class="n">programValid</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">valid</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="c1">// programValid: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programValid</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res20: cats.Eval[(List[ValidationError], Int)] = cats.Eval$$anon$8@7b6b81e9
</span></code></pre>
</div>

<h3 id="invalid">invalid</h3>

<p><code class="highlighter-rouge">invalid</code> accumulates a validation error.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programInvalid</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">invalid</span><span class="o">(</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"oh no"</span><span class="o">))</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">FreeS</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="c1">// programInvalid: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programInvalid</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res21: cats.Eval[(List[ValidationError], Int)] = cats.Eval$$anon$8@57828bad
</span></code></pre>
</div>

<h3 id="errors">errors</h3>

<p><code class="highlighter-rouge">errors</code> allows you to inspect the accumulated errors so far.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programErrors</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">invalid</span><span class="o">(</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"oh no"</span><span class="o">))</span>
    <span class="n">errs</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">errors</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">invalid</span><span class="o">(</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"this won't be in errs"</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">errs</span>
<span class="c1">// programErrors: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],vl.Errors]
</span>
<span class="n">programErrors</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res22: cats.Eval[(List[ValidationError], vl.Errors)] = cats.Eval$$anon$8@5c1ef4c6
</span></code></pre>
</div>

<h3 id="fromeither">fromEither</h3>

<p>We can interleave <code class="highlighter-rouge">Either[ValidationError, ?]</code> values in the program, and if they have errors in the left side they will be accumulated.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programFromEither</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromEither</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"oh no"</span><span class="o">))</span> <span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ValidationError</span>, <span class="kt">Int</span><span class="o">])</span>
	<span class="n">a</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromEither</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ValidationError</span>, <span class="kt">Int</span><span class="o">])</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
<span class="c1">// programFromEither: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Either[ValidationError,Int]]
</span>
<span class="n">programFromEither</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res23: cats.Eval[(List[ValidationError], Either[ValidationError,Int])] = cats.Eval$$anon$8@2213dd1
</span></code></pre>
</div>

<h3 id="fromvalidatednel">fromValidatedNel</h3>

<p>We can interleave <code class="highlighter-rouge">ValidatedNel[ValidationError, ?]</code> values in the program, and if they have errors in the invalid case they will be accumulated.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span><span class="nc">Validated</span><span class="o">,</span> <span class="nc">ValidatedNel</span><span class="o">,</span> <span class="nc">NonEmptyList</span><span class="o">}</span>
<span class="c1">// import cats.data.{Validated, ValidatedNel, NonEmptyList}
</span>
<span class="k">def</span> <span class="n">programFromValidatedNel</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromValidatedNel</span><span class="o">(</span>
	   <span class="nc">Validated</span><span class="o">.</span><span class="nc">Valid</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
	<span class="o">)</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromValidatedNel</span><span class="o">(</span>
	    <span class="nc">Validated</span><span class="o">.</span><span class="n">invalidNel</span><span class="o">[</span><span class="kt">ValidationError</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"oh no"</span><span class="o">))</span>
    <span class="o">)</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="n">vl</span><span class="o">.</span><span class="nc">ValidationM</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">fromValidatedNel</span><span class="o">(</span>
	    <span class="nc">Validated</span><span class="o">.</span><span class="n">invalidNel</span><span class="o">[</span><span class="kt">ValidationError</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nc">NotValid</span><span class="o">(</span><span class="s">"another error!"</span><span class="o">))</span>
    <span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
<span class="c1">// programFromValidatedNel: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],cats.data.ValidatedNel[ValidationError,Int]]
</span>
<span class="n">programFromValidatedNel</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res24: cats.Eval[(List[ValidationError], cats.data.ValidatedNel[ValidationError,Int])] = cats.Eval$$anon$8@17b6b0c1
</span></code></pre>
</div>

<h3 id="syntax">Syntax</h3>

<p>By importing the validation effect implicits, a couple methods are available for lifting valid and invalid values to our program: <code class="highlighter-rouge">liftValid</code> and <code class="highlighter-rouge">liftInvalid</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">programSyntax</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">vl.ValidationM</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="mf">42.</span><span class="n">liftValid</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">NotValid</span><span class="o">(</span><span class="s">"oh no"</span><span class="o">).</span><span class="n">liftInvalid</span>
	<span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">NotValid</span><span class="o">(</span><span class="s">"another error!"</span><span class="o">).</span><span class="n">liftInvalid</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
<span class="c1">// programSyntax: [F[_]](implicit evidence$1: vl.ValidationM[F])cats.free.Free[[β$0$]cats.free.FreeApplicative[F,β$0$],Int]
</span>
<span class="n">programSyntax</span><span class="o">[</span><span class="kt">vl.ValidationM.Op</span><span class="o">].</span><span class="n">exec</span><span class="o">[</span><span class="kt">ValidationResult</span><span class="o">].</span><span class="n">runEmpty</span>
<span class="c1">// res25: cats.Eval[(List[ValidationError], Int)] = cats.Eval$$anon$8@6f7cceff
</span></code></pre>
</div>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/js/main.js"></script><script src="/js/kazari.js"></script><script>
$(document).ready(function() {
	kazari.KazariPlugin().decorateCode('https://scala-evaluator-212.herokuapp.com/eval', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.S2F6YXJp.Jl2eqMfw8IakJF93PjxTbrf-8YUJgX5OoOfy5JHE8Yw', '', 'dracula')
})
    </script></body></html>